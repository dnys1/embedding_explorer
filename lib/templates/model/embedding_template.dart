import 'dart:convert';

import 'package:freezed_annotation/freezed_annotation.dart';

import '../../configurations/model/configuration_collection.dart';
import '../../configurations/model/configuration_item.dart';

part 'embedding_template.freezed.dart';

/// Configuration for an embedding template with metadata
@freezed
abstract class EmbeddingTemplate
    with _$EmbeddingTemplate
    implements ConfigurationItem {
  const factory EmbeddingTemplate({
    required String id,
    required String name,
    required String description,
    required String template,
    required String dataSourceId,
    required List<String> availableFields,
    required Map<String, dynamic> metadata,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) = _EmbeddingTemplate;

  const EmbeddingTemplate._();

  /// Create from database result
  factory EmbeddingTemplate.fromDatabase(Map<String, Object?> row) {
    return EmbeddingTemplate(
      id: row['id'] as String,
      name: row['name'] as String,
      description: row['description'] as String? ?? '',
      template: row['template'] as String? ?? '',
      dataSourceId: row['data_source_id'] as String? ?? '',
      availableFields: row['available_fields'] != null
          ? List<String>.from(
              jsonDecode(row['available_fields'] as String) as List,
            )
          : <String>[],
      metadata: row['metadata'] != null
          ? jsonDecode(row['metadata'] as String) as Map<String, dynamic>
          : <String, dynamic>{},
      createdAt: DateTime.parse(row['created_at'] as String),
      updatedAt: DateTime.parse(row['updated_at'] as String),
    );
  }

  /// Create a default configuration
  factory EmbeddingTemplate.createDefault({
    required String name,
    required String dataSourceId,
    String? description,
    String? template,
    List<String>? availableFields,
    Map<String, dynamic>? metadata,
  }) {
    final now = DateTime.now();
    return EmbeddingTemplate(
      id: 'temp_id', // Will be replaced when added to collection
      name: name,
      description: description ?? '',
      template: template ?? '',
      dataSourceId: dataSourceId,
      availableFields: availableFields ?? [],
      metadata: metadata ?? {},
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Validate the template
  bool get isValid {
    return name.isNotEmpty && template.isNotEmpty && dataSourceId.isNotEmpty;
  }
}

/// Collection for managing embedding template configurations
class EmbeddingTemplateConfigCollection
    extends ConfigurationCollection<EmbeddingTemplate> {
  EmbeddingTemplateConfigCollection(super.configService);

  @override
  String get prefix => 'tmpl';

  @override
  String get tableName => 'templates';

  /// Add a new embedding template configuration
  Future<String> addConfig({
    required String name,
    required String dataSourceId,
    String? description,
    String? template,
    List<String>? availableFields,
    Map<String, dynamic>? metadata,
  }) async {
    final id = generateId();
    final now = DateTime.now();
    final config = EmbeddingTemplate(
      id: id,
      name: name,
      description: description ?? '',
      template: template ?? '',
      dataSourceId: dataSourceId,
      availableFields: availableFields ?? [],
      metadata: metadata ?? {},
      createdAt: now,
      updatedAt: now,
    );

    await upsert(config);
    return id;
  }

  /// Update an existing configuration
  Future<bool> updateConfig(
    String id, {
    String? name,
    String? description,
    String? template,
    String? dataSourceId,
    List<String>? availableFields,
    Map<String, dynamic>? metadata,
  }) async {
    final existing = getById(id);
    if (existing == null) return false;

    // The copyWith method will be generated by freezed after build runner
    final updated = existing.copyWith(
      name: name ?? existing.name,
      description: description ?? existing.description,
      template: template ?? existing.template,
      dataSourceId: dataSourceId ?? existing.dataSourceId,
      availableFields: availableFields ?? existing.availableFields,
      metadata: metadata ?? existing.metadata,
      updatedAt: DateTime.now(),
    );

    await upsert(updated);
    return true;
  }

  /// Get valid templates only
  List<EmbeddingTemplate> getValidTemplates() {
    return all.where((config) => config.isValid).toList();
  }

  /// Search configurations by name or description
  List<EmbeddingTemplate> searchByName(String query) {
    final lowerQuery = query.toLowerCase();
    return all
        .where(
          (config) =>
              config.name.toLowerCase().contains(lowerQuery) ||
              config.description.toLowerCase().contains(lowerQuery),
        )
        .toList();
  }

  /// Get templates that use specific fields
  List<EmbeddingTemplate> getTemplatesUsingFields(List<String> fields) {
    return all
        .where(
          (config) => fields.any((field) => config.template.contains(field)),
        )
        .toList();
  }

  @override
  Future<void> saveItem(EmbeddingTemplate item) async {
    await configService.saveEmbeddingTemplateConfig(item);
  }

  @override
  Future<EmbeddingTemplate?> loadItem(String id) async {
    return await configService.getEmbeddingTemplateConfig(id);
  }

  @override
  Future<List<EmbeddingTemplate>> loadAllItems() async {
    return await configService.getAllEmbeddingTemplateConfigs();
  }

  @override
  Future<void> removeItem(EmbeddingTemplate item) async {
    await configService.deleteEmbeddingTemplateConfig(item.id);
  }
}
